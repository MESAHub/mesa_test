#! /usr/bin/env ruby

# if true, submit cases to localhost:3000 and load local mesa_test library
# rather than system version
DEVELOPMENT_MODE = true

if DEVELOPMENT_MODE
  require_relative '../lib/mesa_test'
else
  require 'mesa_test'
end

require 'thor'
require 'yaml'

class MesaTest < Thor
  DEVELOPMENT_URI = 'http://localhost:3000'.freeze

  desc 'test MESA_DIR [TEST CASE]', 'run and submit a test case or commit'
  long_desc <<-LONGDESC
    You must specify at least a mesa directory, which is a functioning git
    repository. If you specify an optional test case, only that test case
    will be tested. TEST_CASE can also be an integer corresponding to the
    position it has in do1_test_source (or a concatenated version of that file
    if no module is specified). Modules are searched/concatenated in this
    order:

    #{MesaTestCase.modules.map { |mod| '    ' + mod.to_s }.join(', ')}
  LONGDESC

  option :force, desc: 'When submitting, assume submission data in ' +
                       '~/.mesa_test.yml are correct rather than checking ' +
                       'with user.', type: :boolean, default: true,
                       aliases: '-f'
  option :submit, desc: 'Submit results (if any) to MesaTestHub.',
                  type: :boolean, default: true
  option :module, desc: 'Which module to test and/or submit, if applicable.',
                  type: :string, default: 'all', aliases: '-m'                  
  option :log, type: :boolean, default: true, desc: 'Save yml file of test ' \
               'results in test case directory.'
  option :set_sdk, desc: 'Override user- and test-generated data to deterine' +
                   ' if the SDK is used and instead use value of --using_sdk.',
                   type: :boolean, default: false
  option :using_sdk, desc: 'Assume we are using the SDK and automatically ' +
                     'determine SDK version. Ignored unless using --set-sdk).',
                     type: :boolean, default: true

  def test(mesa_dir, test_case_name=nil)
    s = create_and_check_submitter(force: options[:force]) if options[:submit]
    m = create_and_check_mesa(mesa_dir: mesa_dir, 
                              mod: options[:module].downcase.to_sym,
                              using_sdk: using_sdk?(s))
    if test_case_name
      t = create_and_check_test_case(mesa: m, test_case_name: test_case_name,
                                    mod: options[:module].downcase.to_sym)

      # clean and run test
      t.clean
      t.do_one

      # log results
      t.log_results if options[:log]

      # bail out if not submitting
      return unless options[:submit]

      # submit results
      shell.say 'Submitting results to ' + s.base_uri + '... ', :blue
      s.submit(t)
      shell.say "Done.\n", :green
    else
      # run all tests
      m.each_test_run_and_diff(log_results: options[:log],
                               mod: options[:module].downcase.to_sym)

      # submit all tests
      s.submit_commit(m) if options[:submit]
    end
  end

  desc 'submit MESA_DIR [TEST CASE]', 'submit a test case or commit'
  long_desc <<-LONGDESC
    You must specify at least a mesa directory, which is a functioning git
    repository. If you specify an optional test case, only that test case
    will be submitted. TEST_CASE can also be an integer corresponding to the
    position it has in do1_test_source (or a concatenated version of that file
    if no module is specified). Modules are searched/concatenated in this
    order:

    #{MesaTestCase.modules.map { |mod| '    ' + mod.to_s }.join(', ')}
  LONGDESC

  option :force, desc: 'When submitting, assume submission data in ' +
                       '~/.mesa_test.yml are correct rather than checking ' +
                       'with user.', type: :boolean, default: true,
                       aliases: '-f'
  option :module, desc: 'Which module to test and/or submit, if applicable.',
                  type: :string, default: 'all', aliases: '-m'
  option :empty, desc: 'Whether any test cases will be submitted. Useful for' +
                       'indicatinc compilation status independently of ' +
                       'single test submissions.', 
                 type: :boolean, default: false, aliases: '-e'
  
  def submit(mesa_dir, test_case_name=nil)
    s = create_and_check_submitter(force: options[:force])
    m = create_and_check_mesa(mesa_dir: mesa_dir,
                              mod: options[:module].downcase.to_sym,
                              using_sdk: using_sdk?(s))
    if test_case_name
      t = create_and_check_test_case(mesa: m, test_case_name: test_case_name,
                                     mod: options[:module].downcase.to_sym)
      # load test results
      t.load_results

      # submit results
      shell.say 'Submitting results to ' + s.base_uri + '... ', :blue
      s.submit(t)
      shell.say "Done.\n", :green
    else
      begin
        m.check_installation
      rescue MesaDirError
        shell.say %q{This MESA installation doesn't seem to be compiled } \
          'properly. Submitting a compilation failure to MESATestHub.', :red
      else
        # load all test data
        m.each_test_load_results(mod: options[:module].downcase.to_sym)
      ensure
        # submit all tests
        s.submit_commit(m)
      end
    end
  end

  desc 'install SHA MESA_DIR', 'checkout and install a commit'
  long_desc <<-LONGDESC
  Checks out a particular commit to an existing MESA repository clone and
  installs it MESA_DIR. Basically just a git checkout followed by going into
  the directory and running ./clean and ./install. SDK or compilers must be set
  up prior. Does not affect the user's MESA_DIR or other environment variables.
  LONGDESC
  def install(sha, mesa_dir)
    m = Mesa.checkout(sha: sha, mesa_dir: mesa_dir)
    m.clean
    m.install
  end

  desc 'install_and_test SHA MESA_DIR', 'Install, test, and submit an entire '\
  'MESA commit.'
  long_desc <<-LONGDESC
  Checks out a particular commit (specified by SHA) in an existing mesa git
  repository located at MESA_DIR. Then go into the directory
  and run ./clean and ./install. SDK or compilers must be set up prior.
  Once installation is complete, run the test suite, and report results
  (commit and all test data) to MesaTestHub in a single request.
  Does not affect the user's MESA_DIR or other environment variables. This is
  basically a shortcut for running

    `mesa_test install SOME_SHA SOME_DIR`

  followed by

    `mesa_test test SOME_DIR`
  LONGDESC

  option :force, desc: 'When submitting, assume submission data in ' +
                       '~/.mesa_test.yml are correct rather than checking ' +
                       'with user.', type: :boolean, default: true,
                       aliases: '-f'
  option :submit, desc: 'Submit results (if any) to MesaTestHub.',
                  type: :boolean, default: true
  option :set_sdk, desc: 'Override user- and test-generated data to deterine' +
                   ' if the SDK is used and instead use value of --using_sdk.',
                   type: :boolean, default: false
  option :using_sdk, desc: 'Assume we are using the SDK and automatically ' +
                     'determine SDK version. Ignored unless using --set-sdk).',
                     type: :boolean, default: true
  option :module, desc: 'Which module to test and/or submit, if applicable.',
                  type: :string, default: 'all', aliases: '-m'
  option :destroy, type: :boolean, desc: 'Delete mesa installation upon ' \
                   'submission of complete results.', default: false
  option :log, type: :boolean, default: true, desc: 'Save yml file of test ' \
               'results in test case directory.'

  def install_and_test(sha, mesa_dir)
    s = nil # to make sure using_sdk? below will work properly
    s = create_and_check_submitter(force: options[:force]) if options[:submit]
    m = Mesa.download(sha: sha, mesa_dir: mesa_dir, using_sdk: using_sdk?(s))
    begin
      m.clean
      m.install
    rescue MesaDirError
      shell.say "\nFailed in compiling MESA.", :red
    else
      check_mesa(m)
      update_mesa(mesa: m, mod: options[:module].downcase.to_sym)

      # run all tests. Don't be fooled, whether or not a diff happens is set
      # by the diff attribute of the mesa object, set above.
      m.each_test_run_and_diff(mod: options[:module].downcase.to_sym,
                               log_results: options[:log])
    ensure
      # submit all commit and test data
      successfully_submitted = false
      successfully_submitted = s.submit_commit(m) if options[:submit]

      # if requested, installation and submission are successful, destroy the
      # directory
      m.destroy if successfully_submitted && options[:destroy] && m.installed?
    end
  end  

  desc 'setup [CONFIG_FILE]', 'Setup MesaTestHub config file.'
  long_desc <<-LONGDESC
    If optional CONFIG_FILE is provided, search for that file and load it
    to provide default values for configuration. If not provided, the default
    file, ~/.mesa_test.yml, is used. The resulting config file is saved to
    the same location it was read from.
  LONGDESC
  def setup(config_file = File.join(ENV['HOME'], '.mesa_test.yml'))
    MesaTestSubmitter.new_from_config(config_file: config_file,
                                      force_setup: true)
  end

  private

  def check_user_and_computer(submitter)
    computer_check = submitter.confirm_computer
    if computer_check['valid']
      puts computer_check['message']
    else
      $stderr.puts computer_check['message']
      exit 1
    end
  end

  def create_and_check_submitter(force: true)
    s = if DEVELOPMENT_MODE
          MesaTestSubmitter.new_from_config(base_uri: DEVELOPMENT_URI)
        else
          MesaTestSubmitter.new_from_config
        end
    unless force
      s.setup unless s.confirm_computer_data
    end
    check_user_and_computer s
    s
  end

  def create_and_check_mesa(mesa_dir:, mod: :all, using_sdk: true)
    m = Mesa.new(mesa_dir: mesa_dir, using_sdk: using_sdk)
    check_mesa(m)
    update_mesa(mesa: m, mod: mod)
  end

  def check_mesa(mesa)
    unless mesa.downloaded?
      raise MesaDirError, "Invalid MESA_DIR: #{mesa_dir}. Please download " \
      'and install a valid MESA version or provide the path to one.'
    end
  end

  def update_mesa(mesa:, mod: :all)
    mesa.load_test_source_data(mod: mod)
    mesa
  end

  def create_and_check_test_case(mesa:, test_case_name:, mod: :all)
    t = mesa.find_test_case(test_case_name: test_case_name, mod: mod)
    # return test case if it was found
    return t unless t.nil?
    # test case was not found. Throw an error.
    msg = "No such test case, #{test_case_name} found in any of "
    # this should care about the value in `mod`. Current behavior is only
    # appropriate if `mod` is :all.
    msg << MesaTestCase.modules.map do |this_mod|
      File.join(mesa.test_suite_dir(mod: this_mod), 'do1_test_source')
    end.join(' or ')
    msg << '.'
    raise TestCaseDirError, msg
  end

  # determine whether or not we can assume the test should be / was run with
  # the SDK. This results should only be relevant if a test is GOING TO BE RUN.
  # If it has already been run, then the compiler and compiler version have
  # already been set (or the opportunity was lost, either way this won't help.)
  # 
  # This gets used in a lot of places where it probably isn't necessary, just 
  # to prevent problems later on if things change, as it does no harm when it
  # doesn't help.
  # 
  # The only parameter is a submitter, if there is one to lean on. If there
  # isn't, it's no problem.
  def using_sdk?(s = nil)
    # did user specify so? Trust them
    if options[:set_sdk]
      options[:using_sdk]
    # are we submitting? scrape compiler info from that
    elsif s
      s.compiler == 'SDK'
    # we don't have a submitter... need to read config file (same thing 
    # submitter is doing)
    elsif File.exist?(File.join(ENV['HOME'], '.mesa_test.yml'))
      data = YAML.load(File.read(File.join(ENV['HOME'], '.mesa_test.yml')))
      data['compiler'] == 'SDK'
    # nothing works. Don't tell mesa that we are using SDK (we could still be
    # using it, but it's up to a future submitter to tell the web site so.)
    else
      false
    end
  end
end

# actually start the CLI
MesaTest.start(ARGV)
